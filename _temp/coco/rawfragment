use mio::{Events, Interest, Poll, Token};
use mio::net::{TcpListener, TcpStream};
use std::io::{self, Read, Write};
use std::process::{Command, Stdio};
use std::collections::HashMap;
use std::env;

// ... (ServerConfig and Route structs)

const SERVER: Token = Token(0);

fn main() -> io::Result<()> {
  // ... (load server configurations)

  let servers: Result<Vec<ServerConfig>, _> = config.get("servers");
  match servers {
    Ok(servers) => {
      // Store the server configurations in a HashMap for easy lookup
      let servers: HashMap<String, &ServerConfig> = servers.iter().map(|s| (s.server_name.clone(), s)).collect();

      let addr = "127.0.0.1:8080".parse().unwrap();
      let mut server = TcpListener::bind(addr)?;

      let mut poll = Poll::new()?;
      poll.registry().register(&mut server, SERVER, Interest::READABLE)?;

      let mut events = Events::with_capacity(128);

      loop {
          poll.poll(&mut events, None)?;

          for event in events.iter() {
              match event.token() {
                  SERVER => {
                    let (stream, _) = server.accept()?;
                    let mut buffer = [0; 1024];
                    stream.read(&mut buffer)?;

                    // Handle the request here...
                    let request = String::from_utf8_lossy(&buffer);
                    let request_parts: Vec<&str> = request.split("\r\n").collect();
                    let request_line: Vec<&str> = request_parts[0].split(" ").collect();

                    match request_line[0] {
                      "GET" => {
                        let server_name = request_line[2]; // Assume the server name is in the Host header
                        if let Some(server_config) = servers.get(&server_name) {
                          // Use the appropriate server configuration for this request
                          let script_path = server_config.cgi_script; // Assume the server configuration includes the path to a CGI script

                          // Spawn a new process to execute the CGI script
                          let mut child = Command::new("python3")
                              .arg(script_path)
                              .stdin(Stdio::piped())
                              .stdout(Stdio::piped())
                              .spawn()
                              .expect("Failed to execute CGI script");

                          // Write the request body to the CGI script's stdin
                          if let Some(stdin) = child.stdin.as_mut() {
                              stdin.write_all(b"request_body").unwrap();
                          }

                          // Capture the output of the CGI script
                          let output = child.wait_with_output().unwrap();

                          // Write the output of the CGI script to the response
                          let response = format!("HTTP/1.1 200 OK\r\n\r\n{}", String::from_utf8_lossy(&output.stdout));
                          stream.write(response.as_bytes())?;
                          stream.flush()?;
                        }
                      }
                      _ => {
                        let response = "HTTP/1.1 405 Method Not Allowed\r\n\r\n";
                        stream.write(response.as_bytes())?;
                        stream.flush()?;
                      }
                    }
                  }
                  _ => unreachable!(),
              }
          }
      }
    }
    Err(e) => eprintln!("Failed to convert settings into```
